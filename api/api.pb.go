// Code generated by protoc-gen-go.
// source: api/api.proto
// DO NOT EDIT!

package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "go.pedge.io/pb/go/google/protobuf"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// CHANGE: no NONE, was 1 << iota
type Status int32

const (
	Status_STATUS_NONE    Status = 0
	Status_STATUS_INIT    Status = 1
	Status_STATUS_OK      Status = 2
	Status_STATUS_OFFLINE Status = 3
	Status_STATUS_ERROR   Status = 4
)

var Status_name = map[int32]string{
	0: "STATUS_NONE",
	1: "STATUS_INIT",
	2: "STATUS_OK",
	3: "STATUS_OFFLINE",
	4: "STATUS_ERROR",
}
var Status_value = map[string]int32{
	"STATUS_NONE":    0,
	"STATUS_INIT":    1,
	"STATUS_OK":      2,
	"STATUS_OFFLINE": 3,
	"STATUS_ERROR":   4,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// CHANGE: no NONE, was 1 << iota
type DriverType int32

const (
	DriverType_DRIVER_TYPE_NONE      DriverType = 0
	DriverType_DRIVER_TYPE_FILE      DriverType = 1
	DriverType_DRIVER_TYPE_BLOCK     DriverType = 2
	DriverType_DRIVER_TYPE_OBJECT    DriverType = 3
	DriverType_DRIVER_TYPE_CLUSTERED DriverType = 4
	DriverType_DRIVER_TYPE_GRAPH     DriverType = 5
)

var DriverType_name = map[int32]string{
	0: "DRIVER_TYPE_NONE",
	1: "DRIVER_TYPE_FILE",
	2: "DRIVER_TYPE_BLOCK",
	3: "DRIVER_TYPE_OBJECT",
	4: "DRIVER_TYPE_CLUSTERED",
	5: "DRIVER_TYPE_GRAPH",
}
var DriverType_value = map[string]int32{
	"DRIVER_TYPE_NONE":      0,
	"DRIVER_TYPE_FILE":      1,
	"DRIVER_TYPE_BLOCK":     2,
	"DRIVER_TYPE_OBJECT":    3,
	"DRIVER_TYPE_CLUSTERED": 4,
	"DRIVER_TYPE_GRAPH":     5,
}

func (x DriverType) String() string {
	return proto.EnumName(DriverType_name, int32(x))
}
func (DriverType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// CHANGE: was Filesystem, no NONE, was a string
type FSType int32

const (
	FSType_FS_TYPE_NONE  FSType = 0
	FSType_FS_TYPE_BTRFS FSType = 1
	FSType_FS_TYPE_EXT4  FSType = 2
	FSType_FS_TYPE_FUSE  FSType = 3
	FSType_FS_TYPE_NFS   FSType = 4
	FSType_FS_TYPE_VFS   FSType = 5
	FSType_FS_TYPE_XFS   FSType = 6
	FSType_FS_TYPE_ZFS   FSType = 7
)

var FSType_name = map[int32]string{
	0: "FS_TYPE_NONE",
	1: "FS_TYPE_BTRFS",
	2: "FS_TYPE_EXT4",
	3: "FS_TYPE_FUSE",
	4: "FS_TYPE_NFS",
	5: "FS_TYPE_VFS",
	6: "FS_TYPE_XFS",
	7: "FS_TYPE_ZFS",
}
var FSType_value = map[string]int32{
	"FS_TYPE_NONE":  0,
	"FS_TYPE_BTRFS": 1,
	"FS_TYPE_EXT4":  2,
	"FS_TYPE_FUSE":  3,
	"FS_TYPE_NFS":   4,
	"FS_TYPE_VFS":   5,
	"FS_TYPE_XFS":   6,
	"FS_TYPE_ZFS":   7,
}

func (x FSType) String() string {
	return proto.EnumName(FSType_name, int32(x))
}
func (FSType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// CHANGE: was an int, 0 was modified, 1 was added, 2 was deleted
type GraphDriverChangeType int32

const (
	GraphDriverChangeType_GRAPH_DRIVER_CHANGE_TYPE_NONE     GraphDriverChangeType = 0
	GraphDriverChangeType_GRAPH_DRIVER_CHANGE_TYPE_MODIFIED GraphDriverChangeType = 1
	GraphDriverChangeType_GRAPH_DRIVER_CHANGE_TYPE_ADDED    GraphDriverChangeType = 2
	GraphDriverChangeType_GRAPH_DRIVER_CHANGE_TYPE_DELETED  GraphDriverChangeType = 3
)

var GraphDriverChangeType_name = map[int32]string{
	0: "GRAPH_DRIVER_CHANGE_TYPE_NONE",
	1: "GRAPH_DRIVER_CHANGE_TYPE_MODIFIED",
	2: "GRAPH_DRIVER_CHANGE_TYPE_ADDED",
	3: "GRAPH_DRIVER_CHANGE_TYPE_DELETED",
}
var GraphDriverChangeType_value = map[string]int32{
	"GRAPH_DRIVER_CHANGE_TYPE_NONE":     0,
	"GRAPH_DRIVER_CHANGE_TYPE_MODIFIED": 1,
	"GRAPH_DRIVER_CHANGE_TYPE_ADDED":    2,
	"GRAPH_DRIVER_CHANGE_TYPE_DELETED":  3,
}

func (x GraphDriverChangeType) String() string {
	return proto.EnumName(GraphDriverChangeType_name, int32(x))
}
func (GraphDriverChangeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// CHANGE: no NONE
type VolumeActionParam int32

const (
	VolumeActionParam_VOLUME_ACTION_PARAM_NONE VolumeActionParam = 0
	// Maps to the boolean value false
	VolumeActionParam_VOLUME_ACTION_PARAM_OFF VolumeActionParam = 1
	// Maps to the boolean value true.
	VolumeActionParam_VOLUME_ACTION_PARAM_ON VolumeActionParam = 2
)

var VolumeActionParam_name = map[int32]string{
	0: "VOLUME_ACTION_PARAM_NONE",
	1: "VOLUME_ACTION_PARAM_OFF",
	2: "VOLUME_ACTION_PARAM_ON",
}
var VolumeActionParam_value = map[string]int32{
	"VOLUME_ACTION_PARAM_NONE": 0,
	"VOLUME_ACTION_PARAM_OFF":  1,
	"VOLUME_ACTION_PARAM_ON":   2,
}

func (x VolumeActionParam) String() string {
	return proto.EnumName(VolumeActionParam_name, int32(x))
}
func (VolumeActionParam) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// VolumeState represents the state of a volume.
// CHANGE: no NONE, was 1 << iota (and was bit or'ed/and'ed)
type VolumeState int32

const (
	VolumeState_VOLUME_STATE_NONE VolumeState = 0
	// Volume is transitioning to new state
	VolumeState_VOLUME_STATE_PENDING VolumeState = 1
	// Volume is ready to be assigned to a container
	VolumeState_VOLUME_STATE_AVAILABLE VolumeState = 2
	// Volume is attached to container
	VolumeState_VOLUME_STATE_ATTACHED VolumeState = 3
	// Volume is detached but associated with a container
	VolumeState_VOLUME_STATE_DETACHED VolumeState = 4
	// Volume detach is in progress
	VolumeState_VOLUME_STATE_DETATCHING VolumeState = 5
	// Volume is in error state
	VolumeState_VOLUME_STATE_ERROR VolumeState = 6
	// Volume is deleted, it will remain in this state
	// while resources are asynchronously reclaimed
	VolumeState_VOLUME_STATE_DELETED VolumeState = 7
)

var VolumeState_name = map[int32]string{
	0: "VOLUME_STATE_NONE",
	1: "VOLUME_STATE_PENDING",
	2: "VOLUME_STATE_AVAILABLE",
	3: "VOLUME_STATE_ATTACHED",
	4: "VOLUME_STATE_DETACHED",
	5: "VOLUME_STATE_DETATCHING",
	6: "VOLUME_STATE_ERROR",
	7: "VOLUME_STATE_DELETED",
}
var VolumeState_value = map[string]int32{
	"VOLUME_STATE_NONE":       0,
	"VOLUME_STATE_PENDING":    1,
	"VOLUME_STATE_AVAILABLE":  2,
	"VOLUME_STATE_ATTACHED":   3,
	"VOLUME_STATE_DETACHED":   4,
	"VOLUME_STATE_DETATCHING": 5,
	"VOLUME_STATE_ERROR":      6,
	"VOLUME_STATE_DELETED":    7,
}

func (x VolumeState) String() string {
	return proto.EnumName(VolumeState_name, int32(x))
}
func (VolumeState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// VolumeStatus represents a health status for a volume.
// CHANGE: no NONE, was a string
type VolumeStatus int32

const (
	VolumeStatus_VOLUME_STATUS_NONE VolumeStatus = 0
	// Volume is not present
	VolumeStatus_VOLUME_STATUS_NOT_PRESENT VolumeStatus = 1
	// Volume is healthy
	VolumeStatus_VOLUME_STATUS_UP VolumeStatus = 2
	// Volume is in fail mode
	VolumeStatus_VOLUME_STATUS_DOWN VolumeStatus = 3
	// Volume is up but with degraded performance
	// In a RAID group, this may indicate a problem with one or more drives
	VolumeStatus_VOLUME_STATUS_DEGRADED VolumeStatus = 4
)

var VolumeStatus_name = map[int32]string{
	0: "VOLUME_STATUS_NONE",
	1: "VOLUME_STATUS_NOT_PRESENT",
	2: "VOLUME_STATUS_UP",
	3: "VOLUME_STATUS_DOWN",
	4: "VOLUME_STATUS_DEGRADED",
}
var VolumeStatus_value = map[string]int32{
	"VOLUME_STATUS_NONE":        0,
	"VOLUME_STATUS_NOT_PRESENT": 1,
	"VOLUME_STATUS_UP":          2,
	"VOLUME_STATUS_DOWN":        3,
	"VOLUME_STATUS_DEGRADED":    4,
}

func (x VolumeStatus) String() string {
	return proto.EnumName(VolumeStatus_name, int32(x))
}
func (VolumeStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

// VolumeLocator is a structure that is attached to a volume
// and is used to carry opaque metadata.
type VolumeLocator struct {
	// User friendly identifier
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// A set of name-value pairs that acts as search filters
	VolumeLabels map[string]string `protobuf:"bytes,2,rep,name=volume_labels" json:"volume_labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *VolumeLocator) Reset()                    { *m = VolumeLocator{} }
func (m *VolumeLocator) String() string            { return proto.CompactTextString(m) }
func (*VolumeLocator) ProtoMessage()               {}
func (*VolumeLocator) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *VolumeLocator) GetVolumeLabels() map[string]string {
	if m != nil {
		return m.VolumeLabels
	}
	return nil
}

type Source struct {
	// A volume id, if specified will create a clone of the parent.
	Parent string `protobuf:"bytes,1,opt,name=parent" json:"parent,omitempty"`
	// Seed will seed the volume from the specified URI
	// Any additional config for the source comes from the labels in the spec
	Seed string `protobuf:"bytes,2,opt,name=seed" json:"seed,omitempty"`
}

func (m *Source) Reset()                    { *m = Source{} }
func (m *Source) String() string            { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()               {}
func (*Source) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// VolumeSpec has the properties needed to create a volume.
type VolumeSpec struct {
	// Ephemeral storage
	Ephemeral bool `protobuf:"varint,1,opt,name=ephemeral" json:"ephemeral,omitempty"`
	// Thin provisioned volume size in bytes
	Size uint64 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	// Format disk with this FSType
	Format FSType `protobuf:"varint,3,opt,name=format,enum=openstorage.api.FSType" json:"format,omitempty"`
	// Block size for filesystem
	BlockSize int64 `protobuf:"varint,4,opt,name=block_size" json:"block_size,omitempty"`
	// Specifies the number of nodes that are
	// allowed to fail, and yet data is available
	// A value of 0 implies that data is not erasure coded,
	// a failure of a node will lead to data loss
	HaLevel int64 `protobuf:"varint,5,opt,name=ha_level" json:"ha_level,omitempty"`
	// The COS, 1 to 9
	Cos uint32 `protobuf:"varint,6,opt,name=cos" json:"cos,omitempty"`
	// Perform dedupe on this disk
	Dedupe bool `protobuf:"varint,7,opt,name=dedupe" json:"dedupe,omitempty"`
	// SnapshotInterval in minutes, set to 0 to disable snapshots
	SnapshotInterval uint32 `protobuf:"varint,8,opt,name=snapshot_interval" json:"snapshot_interval,omitempty"`
	// Volume configuration labels
	VolumeLabels map[string]string `protobuf:"bytes,9,rep,name=volume_labels" json:"volume_labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *VolumeSpec) Reset()                    { *m = VolumeSpec{} }
func (m *VolumeSpec) String() string            { return proto.CompactTextString(m) }
func (*VolumeSpec) ProtoMessage()               {}
func (*VolumeSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *VolumeSpec) GetVolumeLabels() map[string]string {
	if m != nil {
		return m.VolumeLabels
	}
	return nil
}

// Volume represents a live, created volume.
type Volume struct {
	// Self referential volume ID
	Id       string  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Source   *Source `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	Readonly bool    `protobuf:"varint,3,opt,name=readonly" json:"readonly,omitempty"`
	// User specified locator
	Locator *VolumeLocator `protobuf:"bytes,4,opt,name=locator" json:"locator,omitempty"`
	// Volume creation time
	Ctime *google_protobuf.Timestamp `protobuf:"bytes,5,opt,name=ctime" json:"ctime,omitempty"`
	// User specified VolumeSpec
	Spec *VolumeSpec `protobuf:"bytes,6,opt,name=spec" json:"spec,omitempty"`
	// Volume usage
	Usage uint64 `protobuf:"varint,7,opt,name=usage" json:"usage,omitempty"`
	// Time when an integrity check for run
	LastScan *google_protobuf.Timestamp `protobuf:"bytes,8,opt,name=last_scan" json:"last_scan,omitempty"`
	// Format FSType type if any
	Format FSType       `protobuf:"varint,9,opt,name=format,enum=openstorage.api.FSType" json:"format,omitempty"`
	Status VolumeStatus `protobuf:"varint,10,opt,name=status,enum=openstorage.api.VolumeStatus" json:"status,omitempty"`
	State  VolumeState  `protobuf:"varint,11,opt,name=state,enum=openstorage.api.VolumeState" json:"state,omitempty"`
	// Machine ID (node) on which this volume is attached
	// Machine ID is a node instance identifier for clustered systems.
	AttachedOn string `protobuf:"bytes,12,opt,name=attached_on" json:"attached_on,omitempty"`
	DevicePath string `protobuf:"bytes,14,opt,name=device_path" json:"device_path,omitempty"`
	AttachPath string `protobuf:"bytes,15,opt,name=attach_path" json:"attach_path,omitempty"`
	// Set of machine IDs (nodes) to which this volume is erasure coded - for clustered storage arrays
	ReplicaSet []string `protobuf:"bytes,16,rep,name=replica_set" json:"replica_set,omitempty"`
	// Last recorded error
	Error string `protobuf:"bytes,17,opt,name=error" json:"error,omitempty"`
}

func (m *Volume) Reset()                    { *m = Volume{} }
func (m *Volume) String() string            { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()               {}
func (*Volume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Volume) GetSource() *Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Volume) GetLocator() *VolumeLocator {
	if m != nil {
		return m.Locator
	}
	return nil
}

func (m *Volume) GetCtime() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ctime
	}
	return nil
}

func (m *Volume) GetSpec() *VolumeSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Volume) GetLastScan() *google_protobuf.Timestamp {
	if m != nil {
		return m.LastScan
	}
	return nil
}

type Stats struct {
	// Reads completed successfully
	Reads int64 `protobuf:"varint,1,opt,name=reads" json:"reads,omitempty"`
	// Time spent in reads in ms
	ReadMs    int64 `protobuf:"varint,2,opt,name=read_ms" json:"read_ms,omitempty"`
	ReadBytes int64 `protobuf:"varint,3,opt,name=read_bytes" json:"read_bytes,omitempty"`
	// Writes completed successfully
	Writes int64 `protobuf:"varint,4,opt,name=writes" json:"writes,omitempty"`
	// Time spent in writes in ms
	WriteMs    int64 `protobuf:"varint,5,opt,name=write_ms" json:"write_ms,omitempty"`
	WriteBytes int64 `protobuf:"varint,6,opt,name=write_bytes" json:"write_bytes,omitempty"`
	// IOs curently in progress
	IoProgress int64 `protobuf:"varint,7,opt,name=io_progress" json:"io_progress,omitempty"`
	// Time spent doing IOs ms
	IoMs int64 `protobuf:"varint,8,opt,name=io_ms" json:"io_ms,omitempty"`
	// BytesUsed
	BytesUsed uint64 `protobuf:"varint,9,opt,name=bytes_used" json:"bytes_used,omitempty"`
}

func (m *Stats) Reset()                    { *m = Stats{} }
func (m *Stats) String() string            { return proto.CompactTextString(m) }
func (*Stats) ProtoMessage()               {}
func (*Stats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// TODO: what?
type Alerts struct {
}

func (m *Alerts) Reset()                    { *m = Alerts{} }
func (m *Alerts) String() string            { return proto.CompactTextString(m) }
func (*Alerts) ProtoMessage()               {}
func (*Alerts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type VolumeCreateRequest struct {
	// User specified volume name and labels
	Locator *VolumeLocator `protobuf:"bytes,1,opt,name=locator" json:"locator,omitempty"`
	// Source to create volume
	Source *Source `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	// The storage spec for the volume
	Spec *VolumeSpec `protobuf:"bytes,3,opt,name=spec" json:"spec,omitempty"`
}

func (m *VolumeCreateRequest) Reset()                    { *m = VolumeCreateRequest{} }
func (m *VolumeCreateRequest) String() string            { return proto.CompactTextString(m) }
func (*VolumeCreateRequest) ProtoMessage()               {}
func (*VolumeCreateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *VolumeCreateRequest) GetLocator() *VolumeLocator {
	if m != nil {
		return m.Locator
	}
	return nil
}

func (m *VolumeCreateRequest) GetSource() *Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *VolumeCreateRequest) GetSpec() *VolumeSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

type VolumeResponse struct {
	Error string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *VolumeResponse) Reset()                    { *m = VolumeResponse{} }
func (m *VolumeResponse) String() string            { return proto.CompactTextString(m) }
func (*VolumeResponse) ProtoMessage()               {}
func (*VolumeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

// CHANGE: error was embedded VolumeResponse
type VolumeCreateResponse struct {
	// ID of the newly created volume
	Id             string          `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	VolumeResponse *VolumeResponse `protobuf:"bytes,2,opt,name=volume_response" json:"volume_response,omitempty"`
}

func (m *VolumeCreateResponse) Reset()                    { *m = VolumeCreateResponse{} }
func (m *VolumeCreateResponse) String() string            { return proto.CompactTextString(m) }
func (*VolumeCreateResponse) ProtoMessage()               {}
func (*VolumeCreateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *VolumeCreateResponse) GetVolumeResponse() *VolumeResponse {
	if m != nil {
		return m.VolumeResponse
	}
	return nil
}

// VolumeStateAction specifies desired actions.
type VolumeStateAction struct {
	// Attach or Detach volume
	Attach VolumeActionParam `protobuf:"varint,1,opt,name=attach,enum=openstorage.api.VolumeActionParam" json:"attach,omitempty"`
	// Mount or unmount volume
	Mount     VolumeActionParam `protobuf:"varint,2,opt,name=mount,enum=openstorage.api.VolumeActionParam" json:"mount,omitempty"`
	MountPath string            `protobuf:"bytes,3,opt,name=mount_path" json:"mount_path,omitempty"`
	// Device path returned in attach
	DevicePath string `protobuf:"bytes,4,opt,name=device_path" json:"device_path,omitempty"`
}

func (m *VolumeStateAction) Reset()                    { *m = VolumeStateAction{} }
func (m *VolumeStateAction) String() string            { return proto.CompactTextString(m) }
func (*VolumeStateAction) ProtoMessage()               {}
func (*VolumeStateAction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type VolumeSetRequest struct {
	// User specified volume name and labels
	Locator *VolumeLocator `protobuf:"bytes,1,opt,name=locator" json:"locator,omitempty"`
	// The storage spec for the volume
	Spec *VolumeSpec `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	// State modification on this volume.
	Action *VolumeStateAction `protobuf:"bytes,3,opt,name=action" json:"action,omitempty"`
}

func (m *VolumeSetRequest) Reset()                    { *m = VolumeSetRequest{} }
func (m *VolumeSetRequest) String() string            { return proto.CompactTextString(m) }
func (*VolumeSetRequest) ProtoMessage()               {}
func (*VolumeSetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *VolumeSetRequest) GetLocator() *VolumeLocator {
	if m != nil {
		return m.Locator
	}
	return nil
}

func (m *VolumeSetRequest) GetSpec() *VolumeSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *VolumeSetRequest) GetAction() *VolumeStateAction {
	if m != nil {
		return m.Action
	}
	return nil
}

// CHANGE: error was embedded VolumeResponse
type VolumeSetResponse struct {
	Volume         *Volume         `protobuf:"bytes,1,opt,name=volume" json:"volume,omitempty"`
	VolumeResponse *VolumeResponse `protobuf:"bytes,2,opt,name=volume_response" json:"volume_response,omitempty"`
}

func (m *VolumeSetResponse) Reset()                    { *m = VolumeSetResponse{} }
func (m *VolumeSetResponse) String() string            { return proto.CompactTextString(m) }
func (*VolumeSetResponse) ProtoMessage()               {}
func (*VolumeSetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *VolumeSetResponse) GetVolume() *Volume {
	if m != nil {
		return m.Volume
	}
	return nil
}

func (m *VolumeSetResponse) GetVolumeResponse() *VolumeResponse {
	if m != nil {
		return m.VolumeResponse
	}
	return nil
}

type SnapCreateRequest struct {
	// volume id
	Id       string         `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Locator  *VolumeLocator `protobuf:"bytes,2,opt,name=locator" json:"locator,omitempty"`
	Readonly bool           `protobuf:"varint,3,opt,name=readonly" json:"readonly,omitempty"`
}

func (m *SnapCreateRequest) Reset()                    { *m = SnapCreateRequest{} }
func (m *SnapCreateRequest) String() string            { return proto.CompactTextString(m) }
func (*SnapCreateRequest) ProtoMessage()               {}
func (*SnapCreateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SnapCreateRequest) GetLocator() *VolumeLocator {
	if m != nil {
		return m.Locator
	}
	return nil
}

type SnapCreateResponse struct {
	VolumeCreateResponse *VolumeCreateResponse `protobuf:"bytes,1,opt,name=volume_create_response" json:"volume_create_response,omitempty"`
}

func (m *SnapCreateResponse) Reset()                    { *m = SnapCreateResponse{} }
func (m *SnapCreateResponse) String() string            { return proto.CompactTextString(m) }
func (*SnapCreateResponse) ProtoMessage()               {}
func (*SnapCreateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *SnapCreateResponse) GetVolumeCreateResponse() *VolumeCreateResponse {
	if m != nil {
		return m.VolumeCreateResponse
	}
	return nil
}

type VolumeInfo struct {
	VolumeId string      `protobuf:"bytes,1,opt,name=volume_id" json:"volume_id,omitempty"`
	Path     string      `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	Storage  *VolumeSpec `protobuf:"bytes,3,opt,name=storage" json:"storage,omitempty"`
}

func (m *VolumeInfo) Reset()                    { *m = VolumeInfo{} }
func (m *VolumeInfo) String() string            { return proto.CompactTextString(m) }
func (*VolumeInfo) ProtoMessage()               {}
func (*VolumeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *VolumeInfo) GetStorage() *VolumeSpec {
	if m != nil {
		return m.Storage
	}
	return nil
}

// GraphDriverChanges represent a list of changes between the filesystem layers
// specified by the ID and Parent.  // Parent may be an empty string, in which
// case there is no parent.
// Where the Path is the filesystem path within the layered filesystem
// CHANGE: kind was an int
type GraphDriverChanges struct {
	Path string                `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Kind GraphDriverChangeType `protobuf:"varint,2,opt,name=kind,enum=openstorage.api.GraphDriverChangeType" json:"kind,omitempty"`
}

func (m *GraphDriverChanges) Reset()                    { *m = GraphDriverChanges{} }
func (m *GraphDriverChanges) String() string            { return proto.CompactTextString(m) }
func (*GraphDriverChanges) ProtoMessage()               {}
func (*GraphDriverChanges) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func init() {
	proto.RegisterType((*VolumeLocator)(nil), "openstorage.api.VolumeLocator")
	proto.RegisterType((*Source)(nil), "openstorage.api.Source")
	proto.RegisterType((*VolumeSpec)(nil), "openstorage.api.VolumeSpec")
	proto.RegisterType((*Volume)(nil), "openstorage.api.Volume")
	proto.RegisterType((*Stats)(nil), "openstorage.api.Stats")
	proto.RegisterType((*Alerts)(nil), "openstorage.api.Alerts")
	proto.RegisterType((*VolumeCreateRequest)(nil), "openstorage.api.VolumeCreateRequest")
	proto.RegisterType((*VolumeResponse)(nil), "openstorage.api.VolumeResponse")
	proto.RegisterType((*VolumeCreateResponse)(nil), "openstorage.api.VolumeCreateResponse")
	proto.RegisterType((*VolumeStateAction)(nil), "openstorage.api.VolumeStateAction")
	proto.RegisterType((*VolumeSetRequest)(nil), "openstorage.api.VolumeSetRequest")
	proto.RegisterType((*VolumeSetResponse)(nil), "openstorage.api.VolumeSetResponse")
	proto.RegisterType((*SnapCreateRequest)(nil), "openstorage.api.SnapCreateRequest")
	proto.RegisterType((*SnapCreateResponse)(nil), "openstorage.api.SnapCreateResponse")
	proto.RegisterType((*VolumeInfo)(nil), "openstorage.api.VolumeInfo")
	proto.RegisterType((*GraphDriverChanges)(nil), "openstorage.api.GraphDriverChanges")
	proto.RegisterEnum("openstorage.api.Status", Status_name, Status_value)
	proto.RegisterEnum("openstorage.api.DriverType", DriverType_name, DriverType_value)
	proto.RegisterEnum("openstorage.api.FSType", FSType_name, FSType_value)
	proto.RegisterEnum("openstorage.api.GraphDriverChangeType", GraphDriverChangeType_name, GraphDriverChangeType_value)
	proto.RegisterEnum("openstorage.api.VolumeActionParam", VolumeActionParam_name, VolumeActionParam_value)
	proto.RegisterEnum("openstorage.api.VolumeState", VolumeState_name, VolumeState_value)
	proto.RegisterEnum("openstorage.api.VolumeStatus", VolumeStatus_name, VolumeStatus_value)
}

var fileDescriptor0 = []byte{
	// 1368 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0x4d, 0x73, 0xe3, 0x44,
	0x13, 0x7e, 0x65, 0xcb, 0x4e, 0xd2, 0xce, 0x87, 0x3d, 0xfb, 0xa5, 0xcd, 0x7e, 0xab, 0xde, 0x5d,
	0x16, 0xc3, 0x3a, 0xe0, 0xdd, 0xc3, 0x16, 0x37, 0xc7, 0x96, 0x13, 0x83, 0xd7, 0x76, 0xd9, 0x4a,
	0x58, 0x16, 0xaa, 0x54, 0x8a, 0x3d, 0x1b, 0x9b, 0xc8, 0x92, 0xd0, 0xc8, 0xa1, 0xc2, 0x9f, 0xe0,
	0xc4, 0x01, 0xb8, 0xc1, 0x0d, 0x0e, 0xfc, 0x24, 0xfe, 0x08, 0x07, 0x7a, 0x66, 0xa4, 0x44, 0x8a,
	0xe3, 0x6c, 0x0a, 0x38, 0xa4, 0x52, 0xf3, 0x74, 0x4f, 0x7f, 0x3c, 0xfd, 0xf4, 0xc8, 0xb0, 0x66,
	0xfb, 0x93, 0x2d, 0xfc, 0xab, 0xf8, 0x81, 0x17, 0x7a, 0x64, 0xc3, 0xf3, 0xa9, 0xcb, 0x42, 0x2f,
	0xb0, 0x0f, 0x69, 0x05, 0xe1, 0xcd, 0x07, 0x87, 0x9e, 0x77, 0xe8, 0xd0, 0x2d, 0x61, 0x3e, 0x98,
	0xbd, 0xdd, 0x0a, 0x27, 0x53, 0xca, 0x42, 0x7b, 0xea, 0xcb, 0x1b, 0xfa, 0xcf, 0x0a, 0xac, 0xed,
	0x7b, 0xce, 0x6c, 0x4a, 0xdb, 0xde, 0xd0, 0xc6, 0x9b, 0x64, 0x15, 0x54, 0xd7, 0x9e, 0x52, 0x4d,
	0x79, 0xa8, 0x3c, 0x5d, 0x21, 0x3b, 0xb0, 0x76, 0x2c, 0xcc, 0x96, 0x63, 0x1f, 0x50, 0x87, 0x69,
	0x99, 0x87, 0xd9, 0xa7, 0x85, 0xea, 0x47, 0x95, 0x73, 0x99, 0x2a, 0xa9, 0x20, 0xf1, 0x49, 0x5c,
	0x31, 0xdc, 0x30, 0x38, 0xd9, 0x7c, 0x0e, 0xa5, 0x39, 0x90, 0x14, 0x20, 0x7b, 0x44, 0x4f, 0xa2,
	0x54, 0x6b, 0x90, 0x3b, 0xb6, 0x9d, 0x19, 0xc5, 0x14, 0x78, 0xfc, 0x24, 0xf3, 0x52, 0xd1, 0x9f,
	0x40, 0x7e, 0xe0, 0xcd, 0x82, 0x21, 0x25, 0xeb, 0x90, 0xf7, 0xed, 0x80, 0xba, 0x61, 0xe4, 0x8c,
	0x55, 0x32, 0x4a, 0x47, 0xd2, 0x57, 0xff, 0x23, 0x03, 0x20, 0xa3, 0x0f, 0x7c, 0x3a, 0x24, 0x25,
	0x58, 0xa1, 0xfe, 0x98, 0x4e, 0x69, 0x60, 0x3b, 0xc2, 0x7f, 0x59, 0xf8, 0x4f, 0xbe, 0x93, 0xb1,
	0x55, 0xf2, 0x1e, 0xe4, 0xdf, 0x7a, 0xc1, 0xd4, 0x0e, 0xb5, 0x2c, 0x9e, 0xd7, 0xab, 0xb7, 0xe6,
	0xda, 0x69, 0x0e, 0xcc, 0x13, 0x9f, 0x12, 0x02, 0x70, 0xe0, 0x78, 0xc3, 0x23, 0x4b, 0x5c, 0x56,
	0xd1, 0x39, 0x4b, 0x8a, 0xb0, 0x3c, 0xb6, 0x2d, 0x87, 0x1e, 0x53, 0x47, 0xcb, 0x09, 0x04, 0xdb,
	0x18, 0x7a, 0x4c, 0xcb, 0xe3, 0x61, 0x8d, 0x57, 0x3a, 0xa2, 0xa3, 0x99, 0x4f, 0xb5, 0x25, 0x91,
	0xf9, 0x36, 0x94, 0x98, 0x6b, 0xfb, 0x6c, 0xec, 0x85, 0xd6, 0xc4, 0x0d, 0x69, 0x80, 0x4d, 0x6a,
	0xcb, 0xc2, 0xb5, 0x71, 0x9e, 0xdc, 0x15, 0x41, 0xee, 0xb3, 0x05, 0xe4, 0xf2, 0xde, 0xfe, 0x2b,
	0x66, 0xff, 0xca, 0x42, 0x5e, 0xde, 0xc2, 0x16, 0x33, 0x93, 0x51, 0xe4, 0x89, 0xc4, 0x30, 0x41,
	0xb8, 0x70, 0x2d, 0x5c, 0x40, 0x4c, 0x34, 0x0f, 0x24, 0x21, 0xa0, 0xf6, 0xc8, 0x73, 0x9d, 0x13,
	0xc1, 0xe1, 0x32, 0xd9, 0x82, 0x25, 0x47, 0x4e, 0x5f, 0xf0, 0x54, 0xa8, 0xde, 0xbf, 0x5c, 0x23,
	0xe4, 0x7d, 0xc8, 0x0d, 0xb9, 0x1c, 0x05, 0x89, 0x85, 0xea, 0x66, 0x45, 0x6a, 0xb5, 0x12, 0x6b,
	0xb5, 0x62, 0xc6, 0x5a, 0x45, 0x57, 0x95, 0x61, 0xf3, 0x82, 0xe1, 0x42, 0xf5, 0xce, 0x25, 0xfc,
	0xf0, 0x5e, 0x67, 0x0c, 0x71, 0xc1, 0xbe, 0x4a, 0x9e, 0xc1, 0x8a, 0x63, 0xb3, 0xd0, 0x62, 0x43,
	0xdb, 0x15, 0xac, 0x5f, 0x9e, 0xe8, 0x4c, 0x18, 0x2b, 0x97, 0x0b, 0xe3, 0x19, 0x12, 0x15, 0xda,
	0xe1, 0x8c, 0x69, 0x20, 0x1c, 0xef, 0x2d, 0xaa, 0x49, 0x38, 0x91, 0x0f, 0x20, 0xc7, 0xdd, 0xa9,
	0x56, 0x10, 0xde, 0x77, 0x2f, 0xf1, 0xa6, 0xe4, 0x1a, 0x14, 0xec, 0x30, 0xb4, 0x87, 0x63, 0x3a,
	0xb2, 0x3c, 0x57, 0x5b, 0x15, 0x93, 0x41, 0x70, 0x44, 0x8f, 0x27, 0x43, 0x6a, 0xf9, 0x76, 0x38,
	0xd6, 0xd6, 0x63, 0x50, 0x7a, 0x4a, 0x70, 0x23, 0x06, 0x03, 0xea, 0x3b, 0x93, 0xa1, 0x6d, 0x31,
	0x1a, 0x6a, 0x45, 0xd4, 0x94, 0x90, 0x00, 0x0d, 0x02, 0x9c, 0x4d, 0x49, 0x2c, 0xcc, 0x6f, 0x0a,
	0xe4, 0x78, 0x32, 0xc6, 0x0d, 0x7c, 0x90, 0x4c, 0x08, 0x20, 0x4b, 0x36, 0x60, 0x89, 0x1f, 0xad,
	0x29, 0x13, 0x0a, 0xc8, 0xf2, 0x0d, 0x10, 0xc0, 0xc1, 0x49, 0x48, 0x99, 0x18, 0x75, 0x96, 0x4b,
	0xfc, 0xdb, 0x60, 0xc2, 0xcf, 0xa7, 0x1b, 0x21, 0xce, 0xfc, 0x96, 0xdc, 0x08, 0xac, 0x41, 0x22,
	0xf2, 0x5a, 0x3e, 0x06, 0x27, 0x9e, 0x85, 0xac, 0x1f, 0x06, 0x94, 0x31, 0x31, 0xa0, 0x2c, 0xcf,
	0x8f, 0x20, 0x5e, 0x5c, 0x8e, 0xd3, 0x89, 0x2b, 0xd6, 0x8c, 0xe1, 0x76, 0xf3, 0x21, 0xa8, 0xfa,
	0x32, 0xe4, 0x6b, 0x0e, 0x0d, 0x42, 0xa6, 0xff, 0xa4, 0xc0, 0x35, 0xc9, 0x54, 0x1d, 0x8b, 0x0a,
	0x69, 0x9f, 0x7e, 0x33, 0xc3, 0xc9, 0x25, 0xb5, 0xa7, 0x5c, 0x49, 0x7b, 0x57, 0xd6, 0x79, 0xac,
	0xbc, 0xec, 0x3b, 0x95, 0xa7, 0x3f, 0x80, 0x75, 0x79, 0xea, 0x53, 0xe6, 0x7b, 0x2e, 0xa3, 0x67,
	0xa4, 0x8b, 0xe5, 0xd2, 0xbf, 0x82, 0xeb, 0xe9, 0xe2, 0x23, 0xb7, 0xe4, 0x02, 0xbe, 0x84, 0x8d,
	0xe8, 0x49, 0x08, 0x22, 0x73, 0x54, 0xe1, 0x83, 0x05, 0xa9, 0xe3, 0x28, 0xfa, 0xaf, 0x4a, 0xfc,
	0x0e, 0x08, 0x15, 0xd5, 0x70, 0xb7, 0x3c, 0x97, 0x54, 0x21, 0x2f, 0x15, 0x22, 0xe2, 0xaf, 0x57,
	0xf5, 0x05, 0x61, 0xa4, 0x7b, 0xcf, 0x0e, 0xec, 0x29, 0xf9, 0x18, 0x72, 0x53, 0x6f, 0x86, 0x4f,
	0x6d, 0xe6, 0xca, 0x57, 0xb0, 0x07, 0x71, 0x45, 0xea, 0x30, 0x7b, 0x91, 0x62, 0x55, 0xc1, 0xc1,
	0x2f, 0x0a, 0x14, 0xa3, 0x2a, 0x69, 0xf8, 0x8f, 0xc7, 0x17, 0x4f, 0x25, 0xf3, 0xee, 0xf7, 0x80,
	0x13, 0x20, 0x0a, 0x8d, 0x46, 0xa8, 0x5f, 0xb6, 0x7a, 0xb2, 0x25, 0xfd, 0xf8, 0x94, 0x49, 0x5e,
	0x63, 0x34, 0x25, 0x94, 0x8c, 0x9c, 0x4c, 0x54, 0xe3, 0xad, 0x05, 0x81, 0xfe, 0xc5, 0x08, 0x0f,
	0xa0, 0x34, 0xc0, 0x4f, 0x45, 0x5a, 0xdb, 0x49, 0x75, 0x24, 0x88, 0xca, 0x5c, 0x89, 0xa8, 0xb9,
	0x67, 0x5a, 0xff, 0x12, 0x48, 0x32, 0x47, 0xd4, 0x9c, 0x01, 0x37, 0xa3, 0x9a, 0x87, 0xc2, 0x70,
	0x56, 0xba, 0x6c, 0xf6, 0xf1, 0x82, 0x3c, 0xe9, 0x30, 0x18, 0x3c, 0xfa, 0x0c, 0xb7, 0xdc, 0xb7,
	0x1e, 0xff, 0x0c, 0x47, 0x41, 0x4f, 0x1b, 0xc0, 0xcf, 0xb0, 0x10, 0x83, 0xf8, 0x10, 0x91, 0x0f,
	0x61, 0x29, 0x0a, 0x79, 0x95, 0xfd, 0x7a, 0x0d, 0x64, 0x27, 0xb0, 0xfd, 0x71, 0x23, 0x98, 0x1c,
	0xd3, 0xa0, 0x3e, 0xb6, 0xdd, 0x43, 0xca, 0x4e, 0x23, 0xca, 0xf8, 0x2f, 0x40, 0x3d, 0x9a, 0xb8,
	0xa3, 0x48, 0xb9, 0x4f, 0xe6, 0xc2, 0xcd, 0x05, 0xe0, 0x8f, 0x79, 0xd9, 0xc2, 0x9f, 0x19, 0xf2,
	0x9d, 0xde, 0x80, 0xc2, 0xc0, 0xac, 0x99, 0x7b, 0x03, 0xab, 0xd3, 0xed, 0x18, 0xc5, 0xff, 0x25,
	0x80, 0x56, 0xa7, 0x65, 0x16, 0x15, 0xdc, 0xe9, 0x95, 0x08, 0xe8, 0x7e, 0x56, 0xcc, 0xa0, 0xf0,
	0xd7, 0xe3, 0x63, 0xb3, 0xd9, 0x6e, 0xe1, 0x1d, 0xfe, 0x1c, 0xae, 0x46, 0x98, 0xd1, 0xef, 0x77,
	0xfb, 0x45, 0xb5, 0xfc, 0xa3, 0x02, 0x20, 0xb3, 0x8a, 0x8f, 0xc7, 0x75, 0x28, 0x36, 0xfa, 0xad,
	0x7d, 0xa3, 0x6f, 0x99, 0x5f, 0xf4, 0x8c, 0x38, 0xd5, 0x39, 0xb4, 0xd9, 0x6a, 0x1b, 0x98, 0xef,
	0x06, 0x94, 0x92, 0xe8, 0x76, 0xbb, 0x5b, 0xe7, 0x79, 0x6f, 0x02, 0x49, 0xc2, 0xdd, 0xed, 0x4f,
	0x8d, 0xba, 0x89, 0xb9, 0x6f, 0xc3, 0x8d, 0x24, 0x5e, 0x6f, 0xef, 0x0d, 0x4c, 0xa3, 0x6f, 0x34,
	0x8a, 0xea, 0xf9, 0x48, 0x3b, 0xfd, 0x5a, 0x6f, 0xb7, 0x98, 0x2b, 0xff, 0xa0, 0x40, 0x3e, 0xfa,
	0xa8, 0x61, 0xe1, 0xcd, 0x41, 0xaa, 0xa6, 0x12, 0xac, 0xc5, 0xc8, 0xb6, 0xd9, 0x6f, 0x0e, 0xb0,
	0xa0, 0x84, 0x93, 0xf1, 0xda, 0x7c, 0x81, 0xb5, 0x24, 0x90, 0xe6, 0xde, 0x80, 0x33, 0x80, 0xac,
	0x9d, 0x06, 0xc2, 0x4b, 0x6a, 0x12, 0xd8, 0x47, 0x20, 0x97, 0x04, 0x5e, 0x23, 0x90, 0x4f, 0x02,
	0x6f, 0x10, 0x58, 0x2a, 0xff, 0xae, 0xc0, 0x8d, 0x0b, 0xc7, 0x45, 0x1e, 0xc1, 0x3d, 0x51, 0xbc,
	0x15, 0xb5, 0x53, 0xdf, 0xad, 0x75, 0x76, 0x8c, 0x54, 0xdd, 0x8f, 0xe1, 0xd1, 0x42, 0x97, 0x57,
	0xdd, 0x46, 0xab, 0xd9, 0x42, 0x4a, 0x14, 0xa2, 0xc3, 0xfd, 0x85, 0x6e, 0xb5, 0x46, 0x03, 0x7d,
	0x32, 0xe4, 0xff, 0xf0, 0x70, 0xa1, 0x4f, 0xc3, 0x68, 0x1b, 0x26, 0x7a, 0x65, 0xcb, 0x5f, 0xc7,
	0x4f, 0x46, 0xf2, 0x55, 0xbc, 0x0b, 0xda, 0x7e, 0xb7, 0xbd, 0xf7, 0x0a, 0x83, 0xd5, 0xcd, 0x56,
	0xb7, 0x63, 0xf5, 0x6a, 0xfd, 0xda, 0xab, 0xb8, 0xc6, 0x3b, 0x70, 0xeb, 0x22, 0x2b, 0xea, 0x08,
	0x2b, 0xdb, 0x84, 0x9b, 0x17, 0x1a, 0x3b, 0xc5, 0x4c, 0xf9, 0x4f, 0x05, 0x0a, 0xc9, 0xdf, 0x0b,
	0x38, 0xd8, 0xc8, 0x97, 0xcb, 0xee, 0x94, 0x03, 0x0d, 0x3f, 0x37, 0x49, 0xb8, 0x67, 0x74, 0x1a,
	0xad, 0xce, 0x4e, 0x2a, 0xb8, 0xb4, 0xd4, 0xf6, 0x6b, 0xad, 0x76, 0x6d, 0x1b, 0xf5, 0x96, 0xe1,
	0x02, 0x4a, 0xdb, 0x4c, 0xb3, 0x56, 0xdf, 0xe5, 0x3d, 0xce, 0x99, 0x1a, 0x46, 0x64, 0x52, 0x13,
	0xbd, 0x9c, 0x99, 0xcc, 0xfa, 0x2e, 0x4f, 0x97, 0xe3, 0x5a, 0x4d, 0x19, 0xe5, 0x56, 0xe4, 0xe7,
	0x0a, 0x8c, 0xd9, 0x5c, 0x2a, 0x7f, 0xaf, 0xc0, 0x6a, 0xea, 0xf7, 0x53, 0x3a, 0xc4, 0xd9, 0x7a,
	0xde, 0x83, 0xdb, 0xe7, 0x71, 0xd3, 0xea, 0xf5, 0x8d, 0x81, 0xd1, 0xe1, 0xcb, 0x8a, 0x2b, 0x95,
	0x36, 0xef, 0xf5, 0xe4, 0xee, 0xa4, 0xd1, 0x46, 0xf7, 0xf3, 0x0e, 0xf6, 0x97, 0xa6, 0x85, 0xe3,
	0x06, 0x4e, 0x9e, 0xab, 0x40, 0xdd, 0xbe, 0x0b, 0xd7, 0x86, 0xde, 0xf4, 0xfc, 0x7b, 0xd2, 0x53,
	0xde, 0x64, 0xf1, 0xdf, 0x41, 0x5e, 0xfc, 0x94, 0x7c, 0xfe, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x9c, 0xc2, 0x93, 0xef, 0x8f, 0x0d, 0x00, 0x00,
}
